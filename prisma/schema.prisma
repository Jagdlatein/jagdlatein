// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")

}

model QuizQuestion {
  id         Int      @id @default(autoincrement())
  country    String
  category   String
  topic      String
  question   String
  option_a   String
  option_b   String
  option_c   String
  option_d   String
  correct    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model GlossaryEntry {
  id        Int      @id @default(autoincrement())
  term      String
  slug      String   @unique
  country   String?
  category  String?
  body      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AccessGrant {
  id        Int      @id @default(autoincrement())
  email     String   @db.VarChar(255)
  plan      String?  @db.VarChar(50)
  expiresAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
}

model User {
  id        String   @id           // E-Mail oder anon_<uuid>
  createdAt DateTime @default(now())

  // Gegenkante für 1:1 zu AccessPass (wichtig!)
  access    AccessPass?

  // optionale Back-Relations (nicht zwingend, aber praktisch)
  attempts  QuizAttempt[]
  // Für Feedback gäbe es keine Relation im Model; kann man später ergänzen
}

model AccessPass {
  id        String   @id @default(uuid())
  userId    String   @unique
  plan      String   // "monthly" | "yearly"
  status    String   // "active" | "expired"
  startsAt  DateTime @default(now())
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // 1:1 Relation -> braucht Gegenfeld im User (oben 'access')
  user      User     @relation(fields: [userId], references: [id])
}

model VerificationCode {
  id         String   @id @default(uuid())
  email      String
  code       String
  validUntil DateTime
  used       Boolean  @default(false)
  createdAt  DateTime @default(now())
}

model PaymentEvent {
  id        String   @id @default(uuid())
  provider  String   // "paypal"
  raw       Json
  email     String?
  status    String?
  createdAt DateTime @default(now())
}

model QuizAttempt {
  id        String   @id @default(uuid())
  userId    String
  startedAt DateTime @default(now())
  finishedAt DateTime?
  total     Int      @default(0)
  correct   Int      @default(0)
  durationS Int      @default(0)

  user      User     @relation(fields: [userId], references: [id])
  answers   QuizAnswer[]
}

model QuizAnswer {
  id           String   @id @default(uuid())
  attemptId    String
  questionId   Int
  selected     String   // A|B|C|D
  correct      Boolean
  answeredAt   DateTime @default(now())

  attempt      QuizAttempt @relation(fields: [attemptId], references: [id])
}

model QuizFeedback {
  id          String   @id @default(uuid())
  questionId  Int
  userId      String?
  message     String
  createdAt   DateTime @default(now())
}

model MailLog {
  id        Int      @id @default(autoincrement())
  to        String
  subject   String
  status    String   // "sent" | "error"
  error     String?  // Fehlermeldung
  ip        String? 
  userAgent String?
  createdAt DateTime @default(now())
}


